pub mod grass_material;

use crate::camera::controller::PlayerCamera;
use crate::constants::CHUNK_SIZE;
use crate::rendering::materials::WaterMaterial;
use crate::voxel::meshing::ChunkMesh;
use crate::voxel::plugin::WATER_LEVEL;
use crate::voxel::types::{Voxel, VoxelType};
use crate::voxel::world::VoxelWorld;
use bevy::asset::RenderAssetUsages;
use bevy::light::NotShadowCaster;
use bevy::prelude::*;
use bevy_mesh::{Indices, PrimitiveTopology, VertexAttributeValues};

pub use grass_material::{GrassMaterial, GrassMaterialHandles, GrassMaterialPlugin};

/// Minimal info for a single grass blade instance
struct GrassInstance {
    position: Vec3,
    normal: Vec3,
}

/// Component for grass blade instances
#[derive(Component)]
pub struct GrassBlade;

/// Component for rock props
#[derive(Component)]
pub struct RockProp;

/// Resource to track if grass has been spawned
#[derive(Resource, Default)]
pub struct GrassSpawned(pub bool);

/// Resource to track if rocks have been spawned
#[derive(Resource, Default)]
pub struct RocksSpawned(pub bool);

/// Resource to track if particles have been spawned
#[derive(Resource, Default)]
pub struct ParticlesSpawned(pub bool);

/// Resource to track if trees have been spawned
#[derive(Resource, Default)]
pub struct TreesSpawned(pub bool);

/// Marker that a voxel chunk mesh already has a procedural grass instance attached
#[derive(Component)]
pub struct ChunkGrassAttached;

/// Cached grass assets for the procedural patches
#[derive(Resource, Default)]
pub struct GrassPatchAssets {
    pub blade_mesh: Handle<Mesh>,
    pub materials: Vec<Handle<GrassMaterial>>,
}

/// Build shared grass blade mesh and materials that all patches reuse
pub fn setup_grass_patch_assets(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut grass_materials: ResMut<Assets<GrassMaterial>>,
    mut material_handles: ResMut<GrassMaterialHandles>,
) {
    let blade = meshes.add(create_grass_blade_mesh());
    info!("Created grass blade template mesh");

    // Create grass materials with different color variations (kept vivid to ensure visibility)
    let grass_material_configs = vec![
        GrassMaterial::new(
            LinearRgba::new(0.16, 0.28, 0.05, 1.0), // Deep green base
            LinearRgba::new(0.60, 0.85, 0.35, 1.0), // Bright green tip
            0.35,
            1.8,
            0.08,
        ),
        GrassMaterial::new(
            LinearRgba::new(0.18, 0.32, 0.07, 1.0),
            LinearRgba::new(0.70, 0.90, 0.38, 1.0),
            0.30,
            1.5,
            0.10,
        ),
        GrassMaterial::new(
            LinearRgba::new(0.12, 0.26, 0.06, 1.0),
            LinearRgba::new(0.55, 0.78, 0.32, 1.0),
            0.40,
            2.0,
            0.07,
        ),
    ];

    let material_handles_vec: Vec<Handle<GrassMaterial>> = grass_material_configs
        .into_iter()
        .map(|mat| grass_materials.add(mat))
        .collect();

    material_handles.handles = material_handles_vec.clone();
    info!(
        "Created {} grass material variations",
        material_handles_vec.len()
    );

    commands.insert_resource(GrassPatchAssets {
        blade_mesh: blade,
        materials: material_handles_vec,
    });
    info!("GrassPatchAssets resource initialized");
}

/// Spawn a procedural grass patch for each solid voxel chunk mesh
pub fn attach_procedural_grass_to_chunks(
    mut commands: Commands,
    assets: Res<GrassPatchAssets>,
    water_material: Res<WaterMaterial>,
    mut meshes: ResMut<Assets<Mesh>>,
    // Query chunks with StandardMaterial (blocky mode)
    blocky_chunk_query: Query<
        (
            Entity,
            &ChunkMesh,
            &Mesh3d,
            &MeshMaterial3d<StandardMaterial>,
            &Transform,
        ),
        Without<ChunkGrassAttached>,
    >,
    // Query chunks with TriplanarMaterial (surface nets mode)
    triplanar_chunk_query: Query<
        (
            Entity,
            &ChunkMesh,
            &Mesh3d,
            &MeshMaterial3d<crate::rendering::triplanar_material::TriplanarMaterial>,
            &Transform,
        ),
        Without<ChunkGrassAttached>,
    >,
) {
    // Process blocky chunks
    for (entity, chunk, chunk_mesh, material, transform) in blocky_chunk_query.iter() {
        // Skip water surfaces
        if material.0 == water_material.handle {
            continue;
        }

        process_chunk_for_grass(
            &mut commands,
            &assets,
            &mut meshes,
            entity,
            chunk,
            chunk_mesh,
            transform,
        );
    }

    // Process triplanar chunks (surface nets mode)
    for (entity, chunk, chunk_mesh, _material, transform) in triplanar_chunk_query.iter() {
        process_chunk_for_grass(
            &mut commands,
            &assets,
            &mut meshes,
            entity,
            chunk,
            chunk_mesh,
            transform,
        );
    }
}

/// Helper function to spawn grass on a chunk
fn process_chunk_for_grass(
    commands: &mut Commands,
    assets: &Res<GrassPatchAssets>,
    meshes: &mut ResMut<Assets<Mesh>>,
    entity: Entity,
    chunk: &ChunkMesh,
    chunk_mesh: &Mesh3d,
    transform: &Transform,
) {
    let Some(chunk_source_mesh) = meshes.get(&chunk_mesh.0) else {
        return;
    };

    // Density: blades per square unit; max_count: limit per chunk
    let instances = collect_grass_instances(chunk_source_mesh, transform, 20, 2000);
    if instances.is_empty() {
        return;
    }

    let template_mesh = match meshes.get(&assets.blade_mesh) {
        Some(mesh) => mesh,
        None => return,
    };

    let Some(grass_mesh) = build_grass_patch_mesh(template_mesh, &instances) else {
        return;
    };

    let mesh_handle = meshes.add(grass_mesh);

    // Pick a material handle based on chunk position for deterministic variation
    let material_idx = ((chunk.chunk_position.x.abs() + chunk.chunk_position.z.abs()) as usize)
        % assets.materials.len();
    let material_handle = assets.materials[material_idx].clone();

    commands.entity(entity).insert(ChunkGrassAttached);

    commands.spawn((
        Mesh3d(mesh_handle),
        MeshMaterial3d(material_handle),
        Transform::IDENTITY,
        GlobalTransform::IDENTITY,
        Visibility::Visible,
        InheritedVisibility::VISIBLE,
        ViewVisibility::default(),
    ));
}

/// Extract grass instances from a mesh by sampling upward-facing triangles
fn collect_grass_instances(
    mesh: &Mesh,
    transform: &Transform,
    density: u32,
    max_count: usize,
) -> Vec<GrassInstance> {
    let positions = match mesh.attribute(Mesh::ATTRIBUTE_POSITION) {
        Some(VertexAttributeValues::Float32x3(values)) => values,
        _ => {
            warn!("Mesh has no POSITION attribute");
            return Vec::new();
        }
    };

    let normals = match mesh.attribute(Mesh::ATTRIBUTE_NORMAL) {
        Some(VertexAttributeValues::Float32x3(values)) => values,
        _ => {
            warn!("Mesh has no NORMAL attribute");
            return Vec::new();
        }
    };

    let indices: Vec<u32> = match mesh.indices() {
        Some(Indices::U32(idx)) => idx.clone(),
        Some(Indices::U16(idx)) => idx.iter().map(|i| *i as u32).collect(),
        _ => {
            warn!("Mesh has no indices");
            return Vec::new();
        }
    };

    let mut instances = Vec::new();
    let mut rejected_area = 0;
    let mut rejected_normal = 0;
    let mut accepted = 0;

    // Per-chunk salt so adjacent chunks don't align
    let chunk_seed = {
        let cx = transform.translation.x.floor() as i32;
        let cz = transform.translation.z.floor() as i32;
        mix_bits32(cx as u32 ^ (cz as u32).wrapping_mul(0x9e37_79b9) ^ 0x85eb_ca6b) as i32
    };

    for (tri_idx, tri) in indices.chunks(3).enumerate() {
        if tri.len() < 3 {
            continue;
        }

        let v0 = transform.transform_point(Vec3::from(positions[tri[0] as usize]));
        let v1 = transform.transform_point(Vec3::from(positions[tri[1] as usize]));
        let v2 = transform.transform_point(Vec3::from(positions[tri[2] as usize]));

        // Use the stored normal from the first vertex of the triangle (all 3 should be the same for flat faces)
        let normal_local = Vec3::from(normals[tri[0] as usize]);
        let normal_world = transform.rotation * normal_local; // Transform rotation only, not translation

        let normal = (v1 - v0).cross(v2 - v0);
        let area = normal.length() * 0.5;
        if area <= 0.0001 {
            rejected_area += 1;
            continue;
        }

        let normal_dir = normal_world.normalize();

        if normal_dir.y <= 0.25 {
            rejected_normal += 1;
            continue;
        }

        accepted += 1;

        let blade_count = (density as f32 * area).ceil() as u32;

        // Use centroid with high precision to create unique seeds per triangle
        // Quantize to high-resolution world space and mix triangle + chunk seed to avoid aligned repeats.
        let centroid = (v0 + v1 + v2) / 3.0;
        let qx = (centroid.x * 4096.0).round() as i32;
        let qy = (centroid.y * 4096.0).round() as i32;
        let qz = (centroid.z * 4096.0).round() as i32;

        // Strongly mix hashed components to decorrelate adjacent triangles
        let mut seed_base_bits = (qx as u32).rotate_left(3)
            ^ (qz as u32).rotate_left(17)
            ^ (qy as u32).rotate_left(29)
            ^ (tri_idx as u32).wrapping_mul(0x9e37_79b9)
            ^ chunk_seed as u32;
        seed_base_bits = mix_bits32(seed_base_bits);
        let seed_base = seed_base_bits as i32;

        for i in 0..blade_count {
            // Two independent hashes for barycentric sampling (u1/u2)
            let h1 = mix_bits32(seed_base_bits ^ (i as u32).wrapping_mul(0x85eb_ca6b));
            let h2 =
                mix_bits32(seed_base_bits ^ (i as u32).wrapping_mul(0xc2b2_ae35) ^ 0x27d4_eb2d);
            let u1 = (h1 as f32) / (u32::MAX as f32);
            let u2 = (h2 as f32) / (u32::MAX as f32);
            let r1 = u1.sqrt(); // area-corrected radial factor
            let r2 = u2; // angle factor

            let bary = Vec3::new(1.0 - r1, r1 * (1.0 - r2), r1 * r2);
            let position = v0 * bary.x + v1 * bary.y + v2 * bary.z;

            instances.push(GrassInstance {
                position,
                normal: normal_dir,
            });
            if instances.len() >= max_count {
                return instances;
            }
        }
    }

    instances
}

/// Build a combined grass mesh for all instances using the blade template
fn build_grass_patch_mesh(template: &Mesh, instances: &[GrassInstance]) -> Option<Mesh> {
    if instances.is_empty() {
        return None;
    }

    let positions = match template.attribute(Mesh::ATTRIBUTE_POSITION) {
        Some(VertexAttributeValues::Float32x3(values)) => values,
        _ => return None,
    };
    let normals = match template.attribute(Mesh::ATTRIBUTE_NORMAL) {
        Some(VertexAttributeValues::Float32x3(values)) => Some(values.clone()),
        _ => None,
    };
    let uvs = match template.attribute(Mesh::ATTRIBUTE_UV_0) {
        Some(VertexAttributeValues::Float32x2(values)) => Some(values.clone()),
        _ => None,
    };
    let indices: Vec<u32> = match template.indices() {
        Some(Indices::U32(idx)) => idx.clone(),
        Some(Indices::U16(idx)) => idx.iter().map(|i| *i as u32).collect(),
        _ => return None,
    };

    let base_len = positions.len() as u32;
    let mut out_positions = Vec::with_capacity(positions.len() * instances.len());
    let mut out_normals =
        Vec::with_capacity(normals.as_ref().map(|n| n.len()).unwrap_or(0) * instances.len());
    let mut out_uvs: Vec<[f32; 2]> =
        Vec::with_capacity(uvs.as_ref().map(|u| u.len()).unwrap_or(0) * instances.len());
    let mut out_indices = Vec::with_capacity(indices.len() * instances.len());

    for (i, instance) in instances.iter().enumerate() {
        let hash = simple_hash(
            (instance.position.x as i32).wrapping_add(i as i32 * 13),
            (instance.position.z as i32).wrapping_sub(i as i32 * 7),
        );
        let yaw = hash * std::f32::consts::TAU;
        let scale = 0.8 + simple_hash(i as i32 * 17, i as i32 * 29) * 0.6;

        let align = Quat::from_rotation_arc(Vec3::Y, instance.normal);
        let rotation = align * Quat::from_rotation_y(yaw);
        // Lift slightly along the normal to avoid z-fighting with the ground
        let base_pos = instance.position + instance.normal * 0.05;
        let transform =
            Mat4::from_scale_rotation_translation(Vec3::splat(scale), rotation, base_pos);
        let normal_matrix = Mat3::from_quat(rotation);

        let index_offset = (i as u32) * base_len;

        for idx in &indices {
            out_indices.push(idx + index_offset);
        }

        for pos in positions {
            let world_pos = transform.transform_point3(Vec3::from(*pos));
            out_positions.push(world_pos.to_array());
        }

        if let Some(src_normals) = &normals {
            for n in src_normals {
                let world_normal = normal_matrix * Vec3::from(*n);
                out_normals.push(world_normal.to_array());
            }
        }

        if let Some(src_uvs) = &uvs {
            out_uvs.extend(src_uvs.iter());
        }
    }

    let mut mesh = Mesh::new(
        PrimitiveTopology::TriangleList,
        RenderAssetUsages::default(),
    );
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, out_positions);

    if !out_normals.is_empty() {
        mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, out_normals);
    }

    if !out_uvs.is_empty() {
        mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, out_uvs);
    }

    mesh.insert_indices(Indices::U32(out_indices));

    Some(mesh)
}

/// Component for floating particles (pollen, dust, etc)
#[derive(Component)]
pub struct FloatingParticle {
    pub base_y: f32,
    pub phase: f32,
    pub speed: f32,
    pub drift: Vec3,
}

/// Spawn grass blades on grass block surfaces with wind shader
pub fn spawn_grass_blades(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut grass_materials: ResMut<Assets<GrassMaterial>>,
    mut material_handles: ResMut<GrassMaterialHandles>,
    world: Res<VoxelWorld>,
    mut spawned: ResMut<GrassSpawned>,
) {
    if spawned.0 {
        return;
    }

    // Wait until world has at least one chunk loaded
    if world.get_chunk(IVec3::ZERO).is_none() {
        return;
    }

    spawned.0 = true;

    // Create grass blade mesh (thin vertical quad)
    let grass_mesh = meshes.add(create_grass_blade_mesh());

    // Create grass materials with different color variations
    let grass_material_configs = vec![
        // Golden/yellow grass (dominant in Valheim meadows)
        GrassMaterial::new(
            LinearRgba::new(0.25, 0.20, 0.08, 1.0),
            LinearRgba::new(0.95, 0.85, 0.45, 1.0),
            0.35,
            1.8,
            0.08,
        ),
        // Warm tan grass
        GrassMaterial::new(
            LinearRgba::new(0.30, 0.22, 0.10, 1.0),
            LinearRgba::new(0.85, 0.75, 0.50, 1.0),
            0.30,
            1.5,
            0.10,
        ),
        // Light green-gold mix
        GrassMaterial::new(
            LinearRgba::new(0.15, 0.20, 0.08, 1.0),
            LinearRgba::new(0.70, 0.80, 0.40, 1.0),
            0.40,
            2.0,
            0.07,
        ),
        // Pale straw color
        GrassMaterial::new(
            LinearRgba::new(0.35, 0.30, 0.15, 1.0),
            LinearRgba::new(0.95, 0.90, 0.60, 1.0),
            0.32,
            1.6,
            0.09,
        ),
    ];

    // Create handles and store them for time updates
    let grass_handles: Vec<Handle<GrassMaterial>> = grass_material_configs
        .into_iter()
        .map(|mat| grass_materials.add(mat))
        .collect();

    material_handles.handles = grass_handles.clone();

    let mut grass_count = 0;
    let max_grass = 15000; // Higher limit for denser grass

    // Iterate through world and find grass block tops
    for chunk_x in 0..32 {
        for chunk_z in 0..32 {
            for chunk_y in 0..4 {
                let chunk_pos = IVec3::new(chunk_x, chunk_y, chunk_z);
                if let Some(chunk) = world.get_chunk(chunk_pos) {
                    let chunk_origin = VoxelWorld::chunk_to_world(chunk_pos);

                    for x in 0..16 {
                        for z in 0..16 {
                            for y in 0..16 {
                                if grass_count >= max_grass {
                                    break;
                                }

                                let local = bevy::math::UVec3::new(x, y, z);
                                let voxel = chunk.get(local);

                                // Check if this is a grass block with air above
                                if voxel == VoxelType::TopSoil {
                                    let world_pos =
                                        chunk_origin + IVec3::new(x as i32, y as i32, z as i32);

                                    // Ensure we don't spawn grass underwater or right at the water edge
                                    // +1.0 buffer ensures no grass spawns on blocks that are partially submerged or just touching water surface
                                    if world_pos.y <= WATER_LEVEL + 1 {
                                        continue;
                                    }

                                    let above = world_pos + IVec3::Y;

                                    if let Some(above_voxel) = world.get_voxel(above) {
                                        if above_voxel == VoxelType::Air {
                                            // Spawn grass blades with some randomness
                                            let hash = simple_hash(world_pos.x, world_pos.z);

                                            // Spawn on ~60% of grass blocks for denser coverage
                                            if hash > 0.4 {
                                                let blade_count = 3 + (hash * 4.0) as i32;

                                                for i in 0..blade_count {
                                                    let offset_x = (simple_hash(
                                                        world_pos.x + i * 17,
                                                        world_pos.z,
                                                    ) - 0.5)
                                                        * 0.9;
                                                    let offset_z = (simple_hash(
                                                        world_pos.x,
                                                        world_pos.z + i * 23,
                                                    ) - 0.5)
                                                        * 0.9;
                                                    let rotation = simple_hash(
                                                        world_pos.x * 7 + i,
                                                        world_pos.z * 11,
                                                    ) * std::f32::consts::TAU;
                                                    let scale = 0.6
                                                        + simple_hash(
                                                            world_pos.x + i,
                                                            world_pos.z + i * 5,
                                                        ) * 0.8;

                                                    // Pick material based on hash for color variation
                                                    let material_idx = ((simple_hash(
                                                        world_pos.x + i * 3,
                                                        world_pos.z + i * 7,
                                                    ) * 4.0)
                                                        as usize)
                                                        % grass_handles.len();

                                                    commands.spawn((
                                                        Mesh3d(grass_mesh.clone()),
                                                        MeshMaterial3d(
                                                            grass_handles[material_idx].clone(),
                                                        ),
                                                        Transform::from_xyz(
                                                            world_pos.x as f32 + 0.5 + offset_x,
                                                            world_pos.y as f32 + 1.0,
                                                            world_pos.z as f32 + 0.5 + offset_z,
                                                        )
                                                        .with_rotation(Quat::from_rotation_y(
                                                            rotation,
                                                        ))
                                                        .with_scale(Vec3::splat(scale)),
                                                        GrassBlade,
                                                    ));
                                                    grass_count += 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    info!("Spawned {} grass blades with wind animation", grass_count);
}

/// Create a grass blade mesh (crossed quads) - taller for Valheim look
fn create_grass_blade_mesh() -> Mesh {
    let height = 1.4; // Taller grass like Valheim
    let width = 0.18;

    // Two crossed quads for X shape when viewed from above
    // UV.y goes from 1 (bottom) to 0 (top) for shader compatibility
    let positions = vec![
        // Quad 1 (aligned with X axis)
        [-width, 0.0, 0.0],
        [width, 0.0, 0.0],
        [width * 0.2, height, 0.0], // Narrower at top
        [-width * 0.2, height, 0.0],
        // Quad 2 (aligned with Z axis)
        [0.0, 0.0, -width],
        [0.0, 0.0, width],
        [0.0, height, width * 0.2],
        [0.0, height, -width * 0.2],
    ];

    let normals = vec![
        [0.0, 0.0, 1.0],
        [0.0, 0.0, 1.0],
        [0.0, 0.0, 1.0],
        [0.0, 0.0, 1.0],
        [1.0, 0.0, 0.0],
        [1.0, 0.0, 0.0],
        [1.0, 0.0, 0.0],
        [1.0, 0.0, 0.0],
    ];

    // UVs: y=1 at bottom (no movement), y=0 at top (max movement)
    let uvs = vec![
        [0.0, 1.0],
        [1.0, 1.0],
        [1.0, 0.0],
        [0.0, 0.0],
        [0.0, 1.0],
        [1.0, 1.0],
        [1.0, 0.0],
        [0.0, 0.0],
    ];

    // Vertex colors for additional variation (shader will blend base_color to tip_color)
    let colors: Vec<[f32; 4]> = vec![
        [0.35, 0.30, 0.15, 1.0],
        [0.35, 0.30, 0.15, 1.0],
        [0.95, 0.85, 0.45, 1.0],
        [0.95, 0.85, 0.45, 1.0],
        [0.35, 0.30, 0.15, 1.0],
        [0.35, 0.30, 0.15, 1.0],
        [0.95, 0.85, 0.45, 1.0],
        [0.95, 0.85, 0.45, 1.0],
    ];

    let indices = vec![
        0, 1, 2, 0, 2, 3, // Quad 1 front
        0, 2, 1, 0, 3, 2, // Quad 1 back
        4, 5, 6, 4, 6, 7, // Quad 2 front
        4, 6, 5, 4, 7, 6, // Quad 2 back
    ];

    let mut mesh = Mesh::new(
        PrimitiveTopology::TriangleList,
        RenderAssetUsages::default(),
    );
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh.insert_attribute(Mesh::ATTRIBUTE_COLOR, colors);
    mesh.insert_indices(Indices::U32(indices));
    mesh
}

/// Spawn rock props on the terrain
pub fn spawn_rock_props(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    world: Res<VoxelWorld>,
    mut spawned: ResMut<RocksSpawned>,
) {
    if spawned.0 {
        return;
    }

    // Wait until world has at least one chunk loaded
    if world.get_chunk(IVec3::ZERO).is_none() {
        return;
    }

    spawned.0 = true;

    // Create rock material
    let rock_material = materials.add(StandardMaterial {
        base_color: Color::srgb(0.45, 0.43, 0.4),
        perceptual_roughness: 0.9,
        ..default()
    });

    // Create a few rock mesh variations
    let rock_meshes = vec![
        meshes.add(create_rock_mesh(1.0, 0)),
        meshes.add(create_rock_mesh(0.7, 1)),
        meshes.add(create_rock_mesh(1.3, 2)),
    ];

    let mut rock_count = 0;
    let max_rocks = 200;

    // Scan world for places to put rocks
    for x in 0..512 {
        for z in 0..512 {
            if rock_count >= max_rocks {
                break;
            }

            let world_x = x as i32;
            let world_z = z as i32;

            // Use hash to determine if rock spawns here
            let hash = simple_hash(world_x * 31, world_z * 37);
            if hash > 0.995 {
                // Very sparse rocks
                // Find surface height
                for y in (0..64).rev() {
                    let pos = IVec3::new(world_x, y, world_z);
                    if let Some(voxel) = world.get_voxel(pos) {
                        if voxel.is_solid() && voxel != VoxelType::Water {
                            // Found surface - spawn rock
                            let rock_mesh = &rock_meshes[(hash * 3.0) as usize % 3];
                            let scale = 0.5 + hash * 1.5;
                            let rotation = hash * std::f32::consts::TAU;

                            commands.spawn((
                                Mesh3d(rock_mesh.clone()),
                                MeshMaterial3d(rock_material.clone()),
                                Transform::from_xyz(
                                    world_x as f32 + 0.5,
                                    y as f32 + 1.0 + scale * 0.3,
                                    world_z as f32 + 0.5,
                                )
                                .with_rotation(Quat::from_rotation_y(rotation))
                                .with_scale(Vec3::new(
                                    scale,
                                    scale * 0.6,
                                    scale,
                                )),
                                RockProp,
                            ));
                            rock_count += 1;
                            break;
                        }
                    }
                }
            }
        }
    }

    info!("Spawned {} rock props", rock_count);
}

/// Create a simple rock mesh (deformed sphere)
fn create_rock_mesh(size: f32, _seed: i32) -> Mesh {
    // Use Bevy's built-in sphere and we'll deform it via scale
    Sphere::new(size * 0.5).mesh().build()
}

/// Simple hash function for deterministic randomness
fn simple_hash(x: i32, z: i32) -> f32 {
    let n = x
        .wrapping_mul(374761393)
        .wrapping_add(z.wrapping_mul(668265263));
    let n = (n ^ (n >> 13)).wrapping_mul(1274126177);
    let n = n ^ (n >> 16);
    (n as u32 as f32) / (u32::MAX as f32)
}

// Mix function to decorrelate nearby integer seeds (SplitMix32-style)
fn mix_bits32(mut x: u32) -> u32 {
    x ^= x >> 16;
    x = x.wrapping_mul(0x7feb_352d);
    x ^= x >> 15;
    x = x.wrapping_mul(0x846c_a68b);
    x ^= x >> 16;
    x
}

/// Spawn floating particles around the player for that Valheim atmosphere
pub fn spawn_floating_particles(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut spawned: ResMut<ParticlesSpawned>,
    camera_query: Query<&Transform, With<PlayerCamera>>,
) {
    if spawned.0 {
        return;
    }

    let Ok(camera_transform) = camera_query.single() else {
        return;
    };

    spawned.0 = true;

    let camera_pos = camera_transform.translation;

    // Smaller particle mesh for subtlety
    let particle_mesh = meshes.add(Sphere::new(0.08).mesh().build());

    // Bright golden pollen material - translucent
    let pollen_material = materials.add(StandardMaterial {
        base_color: Color::srgba(1.0, 0.9, 0.4, 0.3), // Translucent
        emissive: LinearRgba::new(2.0, 1.8, 0.5, 1.0), // Reduced glow
        alpha_mode: AlphaMode::Blend,
        unlit: true,
        ..default()
    });

    // Bright white dust material - translucent
    let dust_material = materials.add(StandardMaterial {
        base_color: Color::srgba(1.0, 1.0, 1.0, 0.2), // Very translucent
        emissive: LinearRgba::new(2.0, 2.0, 2.5, 1.0),
        alpha_mode: AlphaMode::Blend,
        unlit: true,
        ..default()
    });

    let particle_count = 20; // Reduced from 200

    for i in 0..particle_count {
        let hash1 = simple_hash(i * 17, i * 31);
        let hash2 = simple_hash(i * 23, i * 47);
        let hash3 = simple_hash(i * 13, i * 53);

        // Spawn in a sphere around camera start position - Not too close
        // Radius 5.0 to 14.0
        let radius = 5.0 + hash1 * 9.0;
        let angle = hash2 * std::f32::consts::TAU;
        let height = (hash3 - 0.5) * 6.0; // -3 to +3 relative to camera

        let x = camera_pos.x + angle.cos() * radius;
        let z = camera_pos.z + angle.sin() * radius;
        let y = camera_pos.y + height;

        let material = if hash1 > 0.6 {
            pollen_material.clone()
        } else {
            dust_material.clone()
        };

        // Visible particle size - varied but small
        let scale = 0.5 + hash2 * 0.8;

        commands.spawn((
            Mesh3d(particle_mesh.clone()),
            MeshMaterial3d(material),
            Transform::from_xyz(x, y, z).with_scale(Vec3::splat(scale)),
            NotShadowCaster,
            FloatingParticle {
                base_y: y,
                phase: hash3 * std::f32::consts::TAU,
                speed: 0.05 + hash1 * 0.05, // Extremely slow bobbing
                drift: Vec3::new(
                    (hash1 - 0.5) * 0.1, // Barely moving drift
                    0.0,
                    (hash2 - 0.5) * 0.1,
                ),
            },
        ));
    }

    info!("Spawned {} floating particles", particle_count);
}

/// Animate floating particles with gentle bobbing and drift
pub fn animate_particles(
    time: Res<Time>,
    camera_query: Query<&Transform, With<PlayerCamera>>,
    mut particles: Query<(&mut Transform, &FloatingParticle), Without<PlayerCamera>>,
) {
    let Ok(camera_transform) = camera_query.single() else {
        return;
    };

    let camera_pos = camera_transform.translation;
    let t = time.elapsed_secs();

    for (mut transform, particle) in particles.iter_mut() {
        // Gentle bobbing motion
        let bob = (t * particle.speed + particle.phase).sin() * 0.2; // Reduced bob amplitude

        // We calculate position relative to camera to keep them around
        // Check distance
        let dist_sq = transform.translation.distance_squared(camera_pos);

        // If too far (radius > 15), wrap to other side
        if dist_sq > 225.0 {
            // 15^2
            // Respawn logic: Teleport to OPPOSITE side of wrap boundary
            // Simply move towards camera by 2x radius? No, that passes through.
            // Just project random position within 10-15 radius in front of camera?

            // Simplest wrapping: If > 15m away, move to random position 10m away in current view direction?
            // Or standard toroidal wrap relative to camera movement?

            // Let's just teleport them to a specific distance in front of the camera slightly randomized
            let forward = camera_transform.forward();
            let right = camera_transform.right();
            let up = camera_transform.up();

            // Random offsets based on particle address (hacky but deterministic-ish)
            let r1 = (transform.translation.x * 7.0).sin();
            let r2 = (transform.translation.z * 13.0).cos();

            let new_pos = camera_pos
                + forward * (8.0 + r1 * 4.0) // 4 to 12m in front
                + right * (r2 * 6.0) // +/- 6m sideways
                + up * (r1 * 4.0); // +/- 4m vertical

            transform.translation = new_pos;
        } else {
            // Normal movement
            transform.translation.y =
                particle.base_y + bob + (camera_pos.y - transform.translation.y) * 0.01; // Slowly follow camera Y
            transform.translation.x += particle.drift.x * time.delta_secs() * 0.3;
            transform.translation.z += particle.drift.z * time.delta_secs() * 0.3;
        }
    }
}

/// Spawn trees on the terrain
pub fn spawn_trees(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    world: Res<VoxelWorld>,
    mut spawned: ResMut<TreesSpawned>,
    player_query: Query<&Transform, With<crate::camera::controller::PlayerCamera>>,
    time: Res<Time>,
) {
    if spawned.0 {
        return;
    }

    // Delay spawning to ensure world is fully loaded and populated
    if time.elapsed_secs() < 10.0 {
        return;
    }

    let Some(player_transform) = player_query.iter().next() else {
        return;
    };

    // Calculate player chunk to ensure we are searching where the world is actually loaded
    let player_pos = player_transform.translation;
    let player_chunk = VoxelWorld::world_to_chunk(player_pos.as_ivec3());

    // Check if player's chunk is loaded
    if world.get_chunk(player_chunk).is_none() {
        return;
    }

    spawned.0 = true;
    info!(
        "Starting tree generation. Target: 15. Player at {}",
        player_pos
    );

    // DEBUG PROBE
    let test_pos = IVec3::new(24, 20, 24);
    if let Some(voxel) = world.get_voxel(test_pos) {
        info!("TREE PROBE at {:?}: {:?}", test_pos, voxel);
    } else {
        warn!("TREE PROBE at {:?}: NONE (Chunk missing?)", test_pos);
    }

    // Load the tree model
    let tree_scene: Handle<Scene> =
        asset_server.load("models/SM_Southern_Oak/SM_Southern_Oak_NN_01b.gltf#Scene0");

    let mut tree_count = 0;
    let target_trees = 15;

    // Random placement settings
    let min_tree_distance = 12.0; // Keep trees from clumping together
    let min_radius = 24.0; // Start spawning a bit away from the player
    let max_radius = 96.0; // Roughly 6 chunks away

    // Seed the pseudo-random placement using player position and time to avoid repetition
    let seed_base =
        player_pos.x as i32 ^ player_pos.z as i32 ^ (time.elapsed_secs() * 1000.0) as i32;

    let mut attempts = 0;
    let max_attempts = 600; // Plenty of samples to find good, spaced spots
    let mut placed_positions: Vec<Vec3> = Vec::new();

    while tree_count < target_trees && attempts < max_attempts {
        // Generate a pseudo-random polar offset from the player
        let rand_radius = simple_hash(seed_base + attempts * 17, seed_base + attempts * 31);
        let rand_angle = simple_hash(seed_base + attempts * 13, seed_base + attempts * 47);

        let radius = min_radius + rand_radius * (max_radius - min_radius);
        let angle = rand_angle * std::f32::consts::TAU;

        let world_x = (player_pos.x + angle.cos() * radius).round() as i32;
        let world_z = (player_pos.z + angle.sin() * radius).round() as i32;

        let column_pos = IVec3::new(world_x, player_pos.y as i32, world_z);
        let chunk_pos = VoxelWorld::world_to_chunk(column_pos);

        if world.get_chunk(chunk_pos).is_some() {
            let chunk_world_origin = VoxelWorld::chunk_to_world(chunk_pos);

            // Scan the column from top to bottom within the chunk bounds
            for y in (0..16).rev() {
                let world_y = chunk_world_origin.y + y as i32;
                let world_pos = IVec3::new(world_x, world_y, world_z);

                if let Some(voxel) = world.get_voxel(world_pos) {
                    if voxel.is_solid() && voxel != VoxelType::Water {
                        // Ensure there is air for the trunk and a bit of canopy
                        let above = world_pos + IVec3::Y;
                        let above_voxel = world.get_voxel(above).unwrap_or(VoxelType::Air);
                        let above2 = world_pos + IVec3::new(0, 2, 0);
                        let above2_voxel = world.get_voxel(above2).unwrap_or(VoxelType::Air);

                        if !above_voxel.is_solid() && !above2_voxel.is_solid() {
                            let spawn_pos = Vec3::new(
                                world_x as f32 + 0.5,
                                world_y as f32 + 1.0,
                                world_z as f32 + 0.5,
                            );

                            // Keep trees separated
                            if placed_positions.iter().all(|p| {
                                p.distance_squared(spawn_pos)
                                    >= min_tree_distance * min_tree_distance
                            }) {
                                let scale_rand =
                                    simple_hash(seed_base + attempts * 3, seed_base + attempts * 5);
                                let rotation_rand = simple_hash(
                                    seed_base + attempts * 11,
                                    seed_base + attempts * 19,
                                );
                                let scale = 0.8 + scale_rand * 0.4;
                                let rotation = rotation_rand * std::f32::consts::TAU;

                                commands.spawn((
                                    SceneRoot(tree_scene.clone()),
                                    Transform::from_xyz(
                                        world_x as f32 + 0.5,
                                        world_y as f32 + 1.0,
                                        world_z as f32 + 0.5,
                                    )
                                    .with_rotation(Quat::from_rotation_y(rotation))
                                    .with_scale(Vec3::splat(scale)),
                                ));

                                placed_positions.push(spawn_pos);
                                tree_count += 1;
                                info!("Spawned tree {} at {}", tree_count, world_pos);
                            }

                            break; // Found ground in this column
                        }
                    }
                }
            }
        }

        attempts += 1;
    }

    if tree_count < target_trees {
        warn!(
            "Finished tree placement with spacing. Spawned {}/{} trees after {} attempts.",
            tree_count, target_trees, attempts
        );
    } else {
        info!(
            "Successfully spawned all {} trees with minimum spacing after {} attempts.",
            tree_count, attempts
        );
    }
}

/// Plugin for vegetation and props
pub struct VegetationPlugin;

impl Plugin for VegetationPlugin {
    fn build(&self, app: &mut App) {
        app
            // Add the grass material plugin first
            .add_plugins(GrassMaterialPlugin)
            .init_resource::<GrassSpawned>()
            .init_resource::<RocksSpawned>()
            .init_resource::<ParticlesSpawned>()
            .init_resource::<TreesSpawned>()
            .add_systems(Startup, setup_grass_patch_assets)
            // Run in Update to ensure world is populated
            .add_systems(
                Update,
                (
                    attach_procedural_grass_to_chunks,
                    spawn_rock_props,
                    spawn_trees,
                    spawn_floating_particles,
                    animate_particles,
                ),
            );
    }
}
